import math



def cos_x(x, terms=50):
    """
    Вычисляет значение cos(x) с использованием ряда Тейлора.

    Подробное описание:
    Функция вычисляет приближенное значение косинуса cos(x), используя разложение в ряд Тейлора.
    Ряд для cos(x) имеет вид: 1 - x^2/2! + x^4/4! - x^6/6! + ... + (-1)^n * x^(2n)/(2n)!

    Аргументы:
    x (float): Значение, для которого вычисляется cos(x).
    terms (int): Количество членов ряда Тейлора для вычисления (по умолчанию 10).

    Возвращаемое значение:
    float: Приближенное значение cos(x).

    Исключения:
    ValueError: Если `terms` не является положительным целым числом.

    Примеры использования:
    >>> cos_x(math.pi / 3)
    0.500000433432915
    >>> cos_x(math.pi, terms=20)
    -1.0
    """
    if not isinstance(terms, int) or terms <= 0:
        raise ValueError("Количество членов ряда должно быть положительным целым числом")

    res = 0
    for n in range(terms):
        res += ((-1) ** n) * (x ** (2 * n)) / math.factorial(2 * n)
    return res



def one_plus_x_pow_m(x, m, terms=50):
    """
    Вычисляет значение (1 + x)^m с использованием ряда Тейлора.

    Подробное описание:
    Функция вычисляет приближенное значение (1 + x)^m, используя разложение в ряд Тейлора.
    Ряд для (1 + x)^m имеет вид: 1 + mx + m(m-1)x^2/2! + m(m-1)(m-2)x^3/3! + ...

    Аргументы:
    x (float): Значение, для которого вычисляется (1 + x)^m. Должно быть в диапазоне -1 < x < 1.
    m (float): Показатель степени.
    terms (int): Количество членов ряда Тейлора для вычисления (по умолчанию 10).

    Возвращаемое значение:
    float: Приближенное значение (1 + x)^m.

    Исключения:
    ValueError: Если `x` не в диапазоне -1 < x < 1 или если `terms` не является положительным целым числом.

    Примеры использования:
    >>> one_plus_x_pow_m(0.5, 2)
    2.25
    >>> one_plus_x_pow_m(0.5, 2, terms=20)
    2.25
    """
    if not -1 < x < 1:
        raise ValueError("Значение x должно быть в диапазоне -1 < x < 1")
    if not isinstance(terms, int) or terms <= 0:
        raise ValueError("Количество членов ряда должно быть положительным целым числом")

    if not (-1 < x < 1):
        raise ValueError("x должен быть в пределах -1 < x < 1")
    result = 1
    term = 1
    for n in range(1, terms):
        term *= (m - n + 1) * x / n
        result += term
    return result



def one_minus_x_pow_m(x, m, terms=50):
    """
    Вычисляет значение (1 - x)^m с использованием ряда Тейлора.

    Подробное описание:
    Функция вычисляет приближенное значение (1 - x)^m, используя разложение в ряд Тейлора.
    Ряд для (1 - x)^m имеет вид: 1 - mx + m(m-1)x^2/2! - m(m-1)(m-2)x^3/3! + ...

    Аргументы:
    x (float): Значение, для которого вычисляется (1 - x)^m. Должно быть в диапазоне -1 < x < 1.
    m (float): Показатель степени.
    terms (int): Количество членов ряда Тейлора для вычисления (по умолчанию 10).

    Возвращаемое значение:
    float: Приближенное значение (1 - x)^m.

    Исключения:
    ValueError: Если `x` не в диапазоне -1 < x < 1 или если `terms` не является положительным целым числом.

    Примеры использования:
    >>> one_minus_x_pow_m(0.5, 2)
    0.25
    >>> one_minus_x_pow_m(0.5, 2, terms=20)
    0.25
    """
    if not -1 < x < 1:
        raise ValueError("Значение x должно быть в диапазоне -1 < x < 1")
    if not isinstance(terms, int) or terms <= 0:
        raise ValueError("Количество членов ряда должно быть положительным целым числом")

    result = 1
    term = 1
    for n in range(1, terms):
        term *= (m - n + 1) * (-x) / n
        result += term
    return result


def exp_pow_x(x, terms=50):
    """
    Вычисляет значение e^x с использованием ряда Тейлора.

    Подробное описание:
    Функция вычисляет приближенное значение экспоненты e^x, используя разложение в ряд Тейлора.
    Ряд для e^x имеет вид: 1 + x + x^2/2! + x^3/3! + ... + x^n/n!

    Аргументы:
    x (float): Значение, для которого вычисляется e^x.
    terms (int): Количество членов ряда Тейлора для вычисления (по умолчанию 10).

    Возвращаемое значение:
    float: Приближенное значение e^x.

    Исключения:
    ValueError: Если `terms` не является положительным целым числом.

    Примеры использования:
    >>> exp_pow_x(1)
    2.7182818011463845
    >>> exp_pow_x(2, terms=20)
    7.389056098930649
    """
    if not isinstance(terms, int) or terms <= 0:
        raise ValueError("Количество членов ряда должно быть положительным целым числом")

    exp_x = 0
    for n in range(terms):
        exp_x += x ** n / math.factorial(n)
    return exp_x


def sin_x(x, terms=50):
    """
    Вычисляет значение sin(x) с использованием ряда Тейлора.

    Подробное описание:
    Функция вычисляет приближенное значение синуса sin(x), используя разложение в ряд Тейлора.
    Ряд для sin(x) имеет вид: x - x^3/3! + x^5/5! - x^7/7! + ...

    Аргументы:
    x (float): Значение, для которого вычисляется sin(x).
    terms (int): Количество членов ряда Тейлора для вычисления (по умолчанию 10).

    Возвращаемое значение:
    float: Приближенное значение sin(x).

    Исключения:
    ValueError: Если `terms` не является положительным целым числом.

    Примеры использования:
    >>> sin_x(math.pi / 2)
    1.0000035425842861
    >>> sin_x(math.pi, terms=20)
    -1.2246467991473532e-16
    """
    if not isinstance(terms, int) or terms <= 0:
        raise ValueError("Количество членов ряда должно быть положительным целым числом")

    sin_x = 0
    for n in range(terms):
        sign = (-1) ** n
        term = sign * (x ** (2 * n + 1)) / math.factorial(2 * n + 1)
        sin_x += term
    return sin_x


def ln_1_plus_x(x, terms=50):
    """
    Вычисляет значение ln(1 + x) с использованием ряда Тейлора.

    Подробное описание:
    Функция вычисляет приближенное значение натурального логарифма ln(1 + x), используя разложение в ряд Тейлора.
    Ряд для ln(1 + x) имеет вид: x - x^2/2 + x^3/3 - x^4/4 + ...

    Аргументы:
    x (float): Значение, для которого вычисляется ln(1 + x). Должно быть в диапазоне -1 < x ≤ 1.
    terms (int): Количество членов ряда Тейлора для вычисления (по умолчанию 10).

    Возвращаемое значение:
    float: Приближенное значение ln(1 + x).

    Исключения:
    ValueError: Если `x` не в диапазоне -1 < x ≤ 1 или если `terms` не является положительным целым числом.

    Примеры использования:
    >>> ln_1_plus_x(0.5)
    0.4054651081081644
    >>> ln_1_plus_x(0.5, terms=20)
    0.4054651081081644
    """
    if not -1 < x <= 1:
        raise ValueError("Значение x должно быть в диапазоне -1 < x ≤ 1")
    if not isinstance(terms, int) or terms <= 0:
        raise ValueError("Количество членов ряда должно быть положительным целым числом")

    ln_x = 0
    for n in range(1, terms + 1):
        term = ((-1) ** (n + 1)) * (x ** n) / n
        ln_x += term
    return ln_x


def main():
    while True:
        print("\nМеню функций:")
        print("1. exp(x) (Экспоненциальная функция)")
        print("2. sin(x) (Синус)")
        print("3. ln(1 + x) (Натуральный логарифм)")
        print("4. cos(x) (Косинус)")
        print("5. (1 + x)^m (Биномиальная функция)")
        print("6. (1 - x)^m (Биномиальная функция с отрицательным x)")
        print("7. Выход")

        choice = input("Выберите функцию (1-7): ")

        if choice == '7':
            break

        if choice not in {'1', '2', '3', '4', '5', '6'}:
            print("Неверный выбор. Попробуйте снова.")
            continue

        try:
            x = float(input("Введите значение x: "))

            if choice in {'5', '6'}:
                m = float(input("Введите значение m: "))
                if choice == '5':
                    result = one_plus_x_pow_m(x, m)
                else:
                    result = one_minus_x_pow_m(x, m)
            else:
                if choice == '1':
                    result = exp_pow_x(x)
                elif choice == '2':
                    result = sin_x(x)
                elif choice == '3':
                    result = ln_1_plus_x(x)
                elif choice == '4':
                    result = cos_x(x)

            print(f"Результат: {result}")

        except ValueError as e:
            print(f"Ошибка: {e}")


if __name__ == "__main__":
    main()